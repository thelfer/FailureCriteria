@DSL DefaultModelDSL{
  automatic_declaration_of_the_temperature_as_first_external_state_variable :
      false
};
@Model BrittleFractureProbability_HoheHardenackeLuckowSiegele2010ExponentialLaw;

@AuxiliaryStateVariable real pf;
pf.setEntryName("LocalFractureProbability");
@ExternalStateVariable strain p;
p.setGlossaryName("EquivalentPlasticStrain");
@ExternalStateVariable StressStensor sig;
sig.setGlossaryName("Stress");

@MaterialProperty real sigma_u;
@MaterialProperty real sigma_th;
@MaterialProperty real alpha_p;
@MaterialProperty real beta_p;


@Integrator {
  if (dp > 0){
    // compute stress triaxiality at the beginning of time step
    const auto eta0 = trace(sig) / (3 * sigmaeq(sig));
    // compute stress triaxiality at the end of time step
    const auto eta1 = trace(eval(sig+dsig)) / (3 * sigmaeq(eval(sig+dsig)));
    // compute stress at the middle of time step
    const auto sig_mts = eval(sig + dsig / 2);
    // compute eigenvalues
    const auto svp_mts = sig_mts.computeEigenValues();
    // sort eigenvalues in descending order
    const auto [s1_mts, s2_mts, s3_mts] = sortEigenValues(svp_mts);
    // compute strain at the middle of timestep
    const auto p_mts = p + dp / 2;
    if (s1_mts > sigma_th){
      const auto su_sI = sigma_u / s1_mts;
      const auto su_sth = sigma_u / sigma_th;
      // compute the increase in local fracture probability
      const auto dpf = beta_p * max(dp - alpha_p*p_mts*(eta1-eta0),0.) * (exp(-alpha_p * eta0) / sqrt(1+alpha_p*alpha_p*p_mts*p_mts)) * (exp(-su_sI*su_sI) - exp(-su_sth*su_sth));
      // compute the new local fracture probability
      pf = pf + dpf;
    }
  }
}
