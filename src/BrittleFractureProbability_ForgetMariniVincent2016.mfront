@DSL DefaultModelDSL{
  automatic_declaration_of_the_temperature_as_first_external_state_variable :
      false
};
@Model BrittleFractureProbability_ForgetMariniVincent2016;

@AuxiliaryStateVariable real pf;
pf.setEntryName("LocalFractureProbability");
@ExternalStateVariable strain p;
p.setGlossaryName("EquivalentPlasticStrain");
@ExternalStateVariable StressStensor sig;
sig.setGlossaryName("Stress");

@MaterialProperty real E;
@MaterialProperty real nu;
@MaterialProperty real gamma_f;
@MaterialProperty real alpha_r;
@MaterialProperty real beta_r;
@MaterialProperty real gamma_r;
@MaterialProperty real mh;
@MaterialProperty real kh;

@Includes {
#include "TFEL/Math/NumericalIntegration/GaussKronrodQuadrature.hxx"
}

@Integrator {
  // stress at the end of timestep
  const auto sig_ets = eval(sig + dsig);
  // compute eigenvalues
  const auto svp_ets = sig_ets.computeEigenValues();
  // sort eigenvalues
  const auto [s1_ets, s2_ets, s3_ets] = sortEigenValues(svp_ets);
  if (s1_ets > 0){
    // function to be integrated
    auto integrand = [this, s1_ets](double r) noexcept {
      auto dF_dr = (2 * alpha_r / beta_r) *
                 std::pow((2 * r - gamma_r) / beta_r, alpha_r - 1) *
                 std::exp(-std::pow((2 * r - gamma_r) / beta_r, alpha_r));
      auto sig_c = sqrt((std::numbers::pi_v<real> * E * gamma_f) /
                      (2 * (1 - nu * nu) * r));
      return dF_dr * exp(-pow(sig_c / (kh * s1_ets), mh));
    };
    // compute Griffith radius
    const auto rg = (std::numbers::pi_v<real> * E * gamma_f) / (2 * (1-nu*nu) * s1_ets * s1_ets);
    // integrate the function
    auto integral1 = tfel::math::gauss_kronrod_integrate(
        integrand, gamma_r, rg,
        {.absolute_tolerance = 1e-12, .maximum_number_of_refinements = 8});
    auto integral2 = tfel::math::gauss_kronrod_integrate(
        integrand, rg, std::numeric_limits<double>::max(),
        {.absolute_tolerance = 1e-12, .maximum_number_of_refinements = 8});
    // compute local fracture probability
    if ((integral2.has_value()) and (integral1.has_value())) {
      pf = ((*integral2) + (*integral1));
    }
  }
}
